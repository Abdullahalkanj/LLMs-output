| Check | Item                                   | What to Check                                                                                               | Why                                                                                                  |
| :---: | -------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
|  \[ ] | Base Case (Termination Condition)      | Role of `if (left < right)` in stopping recursion.                                                          | Ensures the model recognizes when and why the recursion ends, preventing infinite loops.             |
|  \[ ] | Divide Step (Computing `center`)       | Calculation `int center = (left + right) / 2` and how it splits the array.                                  | Critical to “divide and conquer”—the split defines subproblems.                                      |
|  \[ ] | Recursive Calls                        | How `mergeSort(a, tmpArray, left, center)` and `mergeSort(a, tmpArray, center+1, right)` process subarrays. | Demonstrates understanding of recursion and that each half is sorted independently.                  |
|  \[ ] | Merge Function Signature & Parameters  | Meaning of `leftPos`, `rightPos`, `rightEnd`, and `leftEnd`, and why these indices are passed.              | Clarifies how the two sorted halves are delineated for merging.                                      |
|  \[ ] | Core Merging Loop                      | The `while (leftPos <= leftEnd && rightPos <= rightEnd)` with `compareTo` and populating `tmpArray`.        | This is the heart of merging two sorted lists; correctness here guarantees overall sort correctness. |
|  \[ ] | Draining Remaining Elements            | The two `while` loops that copy leftovers from the left or right half.                                      | Handles unequal lengths and ensures no element is lost.                                              |
|  \[ ] | Copying Back to Original Array         | The final `for (int i = 0; i < numElements; i++, rightEnd--) a[rightEnd] = tmpArray[rightEnd];`             | Explains how merged results are written back, completing the in-place sort.                          |
|  \[ ] | Role of `tmpArray` (Auxiliary Space)   | Why a temporary array is needed, and how it affects space complexity.                                       | Highlights trade-off: O(n) extra space for guaranteed O(n log n) time.                               |
|  \[ ] | Use of `Comparable` & `compareTo`      | How `a[leftPos].compareTo(a[rightPos])` drives ordering.                                                    | Demonstrates reliance on Java’s `Comparable` interface for generic comparison.                       |
|  \[ ] | Handling Edge Cases                    | Behavior on empty array (`right < left` immediately) or single-element subarrays.                           | Confirms robustness and correct handling of minimal inputs.                                          |
|  \[ ] | Parameter Roles & Pre-/Post-conditions | Clear description of what each parameter represents (e.g. `a`: data array; `left`/`right`: bounds).         | Prevents confusion and makes it clear how to call or adapt the method.                               |
|  \[ ] | High-Level Algorithm Summary           | A brief “divide → sort halves → merge” overview.                                                            | Gives the reader the “big picture” before diving into details.                                       |

