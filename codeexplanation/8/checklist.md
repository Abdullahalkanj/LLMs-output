| Check | Item                                      | What to Check                                                                                                                                               | Why                                                                                                              |
| :---: | ----------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
|  \[ ] | `Empty` exception                         | Is it noted that `Empty` is a custom exception used to signal operations on an empty priority queue?                                                        | Clarifies how error conditions are represented and propagated.                                                   |
|  \[ ] | `PriorityQueueBase.Item`                  | Does the explanation cover the `Item` class’s `key`/`value` slots and its `__lt__` method for comparing keys?                                               | Shows how entries are stored and compared, foundational for heap ordering.                                       |
|  \[ ] | `PriorityQueueBase.is_empty`              | Is it stated that `is_empty()` returns `len(self) == 0`, leveraging `__len__` from subclasses?                                                              | Confirms the basic emptiness check across all PQ variants.                                                       |
|  \[ ] | `HeapPriorityQueue.__init__`              | Does it explain that `self.data` is initialized as an empty list to store heap entries?                                                                     | Establishes the underlying array representation for the heap.                                                    |
|  \[ ] | Index helpers (`parent`, `left`, `right`) | Are the index‐calculation methods (`parent(j)`, `left(j)`, `right(j)`) and their integer‐division logic described?                                          | Verifies understanding of the implicit binary‐tree structure in the array.                                       |
|  \[ ] | Boundary checks (`has_left`, `has_right`) | Does it explain how `has_left(j)` and `has_right(j)` guard against invalid child indices?                                                                   | Ensures safety when traversing the heap during downheap.                                                         |
|  \[ ] | `swap`                                    | Is it noted that `swap(i,j)` exchanges `self.data[i]` and `self.data[j]`?                                                                                   | Fundamental operation for restoring heap order.                                                                  |
|  \[ ] | `upheap`                                  | Are the recursive steps of `upheap(j)`—comparing child to parent, swapping if out of order, recursing on parent—clearly outlined?                           | Explains how newly added entries “bubble up” to maintain heap invariant.                                         |
|  \[ ] | `downheap`                                | Is the process in `downheap(j)`—finding the smaller child, swapping if parent is larger, recursing on that child—detailed?                                  | Shows how removing the min or updating an entry restores heap order by “sifting down.”                           |
|  \[ ] | `__len__`                                 | Does it explain that `__len__()` returns the number of items (length of `self.data`)?                                                                       | Connects Python’s `len(pq)` to the current heap size.                                                            |
|  \[ ] | `add`                                     | Are the steps in `add(key, value)`—creating an `Item`, appending it, and calling `upheap`—covered?                                                          | Ensures understanding of how new entries are inserted and placed correctly in the heap.                          |
|  \[ ] | `min`                                     | Does it mention that `min()` returns `(key, value)` of `self.data[0]` or raises `Empty` if empty?                                                           | Clarifies how to retrieve the smallest entry without modification and error handling.                            |
|  \[ ] | `remove_min`                              | Are the swap‐pop‐downheap steps in `remove_min()`—swap root with last, pop last, call `downheap`, return popped item—explained?                             | Demonstrates the complete process of deleting and returning the minimum element while preserving heap invariant. |
|  \[ ] | `Locator` class                           | Does the explanation cover that `Locator` extends `Item` by adding an `index` slot to track its position in the heap?                                       | Key for enabling adaptable operations by remembering each entry’s location.                                      |
|  \[ ] | Adaptable `swap` override                 | Is it noted that the overridden `swap` updates each swapped locator’s `index` field?                                                                        | Ensures locator objects remain in sync with their position in the underlying array.                              |
|  \[ ] | `bubble`                                  | Does it explain how `bubble(j)` decides whether to `upheap` or `downheap` based on the updated locator’s key?                                               | Shows how changing an entry’s key/value restores heap order in either direction.                                 |
|  \[ ] | Adaptable `add`                           | Are the steps in `add(key, value)`—creating a `Locator`, appending it, running `upheap`, and returning the locator—described?                               | Critical for clients to receive a handle to the entry for later updates or removal.                              |
|  \[ ] | `update`                                  | Does it mention how `update(loc, newkey, newval)` validates the locator, updates its key/value, and calls `bubble`?                                         | Explains how to change priorities dynamically while maintaining heap order.                                      |
|  \[ ] | `remove`                                  | Is the removal of an arbitrary locator—swap it with last, pop, bubble from its index, return its key/value—clearly outlined?                                | Shows the full process for deleting any entry, not just the minimum, while preserving the heap structure.        |
|  \[ ] | `__main__` demo                           | Does it note that the demo adds entries, updates one key, removes one via locator, and then repeatedly calls `remove_min()` to print all remaining entries? | Ties together all API methods to show end-to-end usage and expected output sequence.                             |
