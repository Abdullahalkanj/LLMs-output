| Check | Item                         | What to Check                                                                                                                                               | Why                                                                                                              |
| :---: | ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
|   ✔️   | `Empty` exception            | Is it noted that `Empty` is a custom exception used to signal operations on an empty priority queue?                                                        | Clarifies how error conditions are represented and propagated.                                                   |
|   ✔️   | `PriorityQueueBase.Item`     | Does the explanation cover the `Item` class’s `key`/`value` slots and its `__lt__` method for comparing keys?                                               | Shows how entries are stored and compared, foundational for heap ordering.                                       |
|   ✔️   | `PriorityQueueBase.is_empty` | Is it stated that `is_empty()` returns `len(self) == 0`, leveraging `__len__` from subclasses?                                                              | Confirms the basic emptiness check across all PQ variants.                                                       |
|   ✔️   | `HeapPriorityQueue.__init__` | Does it explain that `self.data` is initialized as an empty list to store heap entries?                                                                     | Establishes the underlying array representation for the heap.                                                    |
|   ✔️   | Index helpers                | Are the index-calculation methods (`parent`, `left`, `right`, `has_left`, `has_right`) and their integer-division logic described?                          | Verifies understanding of the implicit binary-tree structure in the array.                                       |
|   ✔️   | Boundary checks              | Does it explain how `has_left(j)` and `has_right(j)` guard against invalid child indices?                                                                   | Ensures safety when traversing the heap during downheap.                                                         |
|   ✔️   | `swap`                       | Is it noted that `swap(i,j)` exchanges two entries in `self.data`?                                                                                          | Fundamental operation for restoring heap order.                                                                  |
|   ✔️   | `upheap`                     | Are the recursive steps of `upheap(j)`—comparing child to parent, swapping if out of order, recursing upward—clearly outlined?                              | Explains how newly added entries “bubble up” to maintain the heap invariant.                                     |
|   ✔️   | `downheap`                   | Is the process in `downheap(j)`—finding the smaller child, swapping if parent is larger, recursing downward—detailed?                                       | Shows how removing the min or updating an entry restores heap order by “sifting down.”                           |
|   ✔️   | `__len__`                    | Does it explain that `__len__()` returns the number of elements in the heap (`len(self.data)`) so `len(pq)` works?                                          | Connects Python’s `len(pq)` to the current heap size.                                                            |
|   ✔️   | `add`                        | Are the steps in `add(key, value)`—creating an `Item`, appending it, then calling `upheap`—covered?                                                         | Ensures understanding of how new entries are inserted and placed correctly in the heap.                          |
|   ✔️   | `min`                        | Does it mention that `min()` returns the smallest `(key, value)` at the root or raises `Empty` if the heap is empty?                                        | Clarifies how to retrieve the smallest entry without modification and handles error conditions.                  |
|   ✔️   | `remove_min`                 | Are the swap-pop-downheap steps in `remove_min()`—swap root with last, pop it, call `downheap`, return removed pair—explained?                              | Demonstrates the complete process of deleting and returning the minimum element while preserving heap invariant. |
|   ✔️   | `Locator` class              | Does the explanation cover that `Locator` extends `Item` by adding an `index` field to track its position in the heap?                                      | Key for enabling adaptable operations by remembering each entry’s location.                                      |
|   ✔️   | Adaptable `swap` override    | Is it noted that the overridden `swap` updates each swapped locator’s `index` field?                                                                        | Ensures locator objects remain in sync with their position in the array.                                         |
|   ✔️   | `bubble`                     | Does it explain how `bubble(j)` chooses between `upheap` or `downheap` after a key change?                                                                  | Shows how changing an entry’s key/value restores heap order in either direction.                                 |
|   ✔️   | Adaptable `add`              | Are the steps in `add(key, value)`—creating a `Locator`, appending it, calling `upheap`, and returning the locator—described?                               | Critical for clients to receive a handle to the entry for later updates or removal.                              |
|   ✔️   | `update`                     | Does it mention how `update(loc, newkey, newval)` validates the locator, updates its key/value, and calls `bubble`?                                         | Explains how to change priorities dynamically while maintaining heap order.                                      |
|   ✔️   | `remove`                     | Is the removal of an arbitrary locator—swap with last, pop, call `bubble`, return removed pair—clearly outlined?                                            | Shows the full process for deleting any entry, not just the minimum, while preserving heap structure.            |
|   ✔️   | `__main__` demo              | Does it note that the demo adds entries, updates one key, removes one via locator, and then repeatedly calls `remove_min()` to print all remaining entries? | Ties together all API methods to show end-to-end usage and expected output sequence.                             |
