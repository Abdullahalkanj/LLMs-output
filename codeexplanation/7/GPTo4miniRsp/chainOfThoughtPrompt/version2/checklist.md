| Check | Item                   | What to Check                                                                                                                                             | Why                                                                                              |
| :---: | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
|   ✔️  | `Empty` exception      | Is it noted that `Empty` is a custom exception used to signal operations on an empty queue?                                                               | Clarifies how error conditions are represented and handled.                                      |
|  ✔️  | `Node` inner class     | Does the explanation state that each `Node` holds an `element` and a `next` pointer for the linked queue?                                                 | Ensures understanding of the basic building block of the linked list.                            |
|  ✔️  | `LinkedQueue.__init__` | Is it clear that `head` and `tail` both start as `None` and `size` as `0`, establishing an empty queue?                                                   | Shows how the queue’s initial, empty state is set up.                                            |
|  ✔️  | `LinkedQueue.__len__`  | Does it explain that `__len__` returns the current `size`, enabling use of `len(Q)`?                                                                      | Connects Python’s built-in `len()` to the queue’s size tracking.                                 |
|  ✔️  | `is_empty`             | Is it stated that `is_empty` checks `size == 0`, providing a quick way to test for emptiness?                                                             | Highlights a common precondition check used throughout.                                          |
|  ✔️  | `enqueue`              | Are the steps covered: wrap the element in a new node, link it at the tail (or set head if empty), update `tail`, increment `size`?                       | Verifies understanding of how items are added and state is updated.                              |
|  ✔️  | `dequeue`              | Does it note: raise `Empty` if empty; remove and return the head element, advance `head`, decrement `size`, clear `tail` if now empty?                    | Confirms awareness of removal logic, exception path, and maintaining invariants (`head`/`tail`). |
|  ✔️  | `first`                | Is it explained that `first` peeks at `head.element` (or raises `Empty`) without modifying the queue?                                                     | Distinguishes peek vs. removal and shows error handling.                                         |
|  ✔️  | `quick_sort_queue`     | Are the partitioning steps covered: base case (`n<2`), pivot selection, three-way partition into `L`/`E`/`G`, recursion, and concatenation back into `S`? | Ensures the model captures the non-in-place, recursive queue-based quick sort process.           |
|  ✔️  | `inplace_quick_sort`   | Does it explain the in-place algorithm: base case (`a>=b`), pivot as `S[b]`, two-pointer partition loop with swaps, pivot placement, and recursion?       | Verifies understanding of the classic array-based quick sort implementation.                     |
|  ✔️  | `__main__` block       | Is it noted that the demo enqueues `[3,1,4,1,5,9,2]`, sorts via both methods, and prints the sorted results for both queue and list?                      | Ties all parts together by explaining end-to-end behavior when executing the script.             |
