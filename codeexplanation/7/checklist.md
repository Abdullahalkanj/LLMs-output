| Check | Item                   | What to Check                                                                                                                                                | Why                                                                                                |
| :---: | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
|  \[ ] | `Empty` exception      | Is it noted that `Empty` is a custom exception used to signal operations on an empty queue?                                                                  | Clarifies how error conditions are represented and handled.                                        |
|  \[ ] | `Node` inner class     | Does the explanation state that each `Node` holds an `element` and a `next` pointer for the linked queue?                                                    | Ensures understanding of the basic building block of the linked list.                              |
|  \[ ] | `LinkedQueue.__init__` | Is it clear that `head` and `tail` both start as `None` and `size` as `0`, establishing an empty queue?                                                      | Shows how the queue’s initial, empty state is set up.                                              |
|  \[ ] | `LinkedQueue.__len__`  | Does it explain that `__len__` returns the current `size`, enabling use of `len(Q)`?                                                                         | Connects Python’s built-in `len()` to the queue’s size tracking.                                   |
|  \[ ] | `is_empty`             | Is it stated that `is_empty` checks `size == 0`, providing a quick way to test for emptiness?                                                                | Highlights a common precondition check used throughout.                                            |
|  \[ ] | `enqueue`              | Are the steps covered: create new node, link it from `tail` (or set `head` if empty), update `tail`, increment `size`?                                       | Verifies model understands how items are added and state is updated.                               |
|  \[ ] | `dequeue`              | Does it note: raise `Empty` if empty; remove `head`, advance it to `head.next`, decrement `size`, clear `tail` if now empty, return element?                 | Confirms awareness of removal logic, exception path, and maintaining invariants (`head`/`tail`).   |
|  \[ ] | `first`                | Is it explained that `first` returns `head.element` (or raises `Empty`) without modifying the queue?                                                         | Distinguishes peek vs. removal and shows error handling.                                           |
|  \[ ] | `quick_sort_queue`     | Are the partitioning steps covered: pick pivot via `first()`, distribute to `L`, `E`, `G` by dequeuing, recurse on `L`/`G`, then reenqueue in order?         | Ensures model captures the non-in-place, recursive queue-based quick sort process.                 |
|  \[ ] | `inplace_quick_sort`   | Does it explain the in-place algorithm: choose last element as pivot, two-index scan to swap out-of-place elements, swap pivot into final position, recurse? | Verifies understanding of the classic array-based quick sort implementation.                       |
|  \[ ] | `__main__` block       | Is it noted that, when run as a script, it enqueues `[3,1,4,1,5,9,2]`, sorts via both methods, and prints the sorted results?                                | Ties all parts together by explaining how the classes/functions are exercised and outputs checked. |
